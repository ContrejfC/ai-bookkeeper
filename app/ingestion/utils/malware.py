"""
Malware Scanning Interface
==========================

Interface for ClamAV malware scanning with graceful degradation.
"""

import logging
import subprocess
from typing import Tuple, Optional
from app.ingestion.config import config

logger = logging.getLogger(__name__)


class MalwareScanner:
    """
    ClamAV-based malware scanner with feature flag support.
    
    When scanning is disabled or ClamAV is unavailable, degrades gracefully.
    """
    
    def __init__(self):
        self.enabled = config.MALWARE_SCAN_ENABLED
        self.available = self._check_clamav_available()
        
        if self.enabled and not self.available:
            logger.warning(
                "Malware scanning enabled but ClamAV not available. "
                "Scans will be skipped."
            )
    
    def _check_clamav_available(self) -> bool:
        """Check if ClamAV is available."""
        if not self.enabled:
            return False
        
        try:
            result = subprocess.run(
                ['clamscan', '--version'],
                capture_output=True,
                timeout=5
            )
            available = result.returncode == 0
            if available:
                logger.info(f"ClamAV available: {result.stdout.decode().strip()}")
            return available
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False
        except Exception as e:
            logger.error(f"Error checking ClamAV availability: {e}")
            return False
    
    def scan_file(self, file_path: str) -> Tuple[bool, Optional[str]]:
        """
        Scan a file for malware.
        
        Args:
            file_path: Path to file to scan
        
        Returns:
            Tuple of (is_clean, scan_result)
            - is_clean: True if file is clean or scanning is disabled
            - scan_result: Scan result message or None
        """
        if not self.enabled:
            logger.debug("Malware scanning disabled")
            return True, "Scanning disabled"
        
        if not self.available:
            logger.warning("ClamAV not available, skipping scan")
            return True, "Scanner not available"
        
        try:
            # Run clamscan
            result = subprocess.run(
                [
                    'clamscan',
                    '--no-summary',
                    '--infected',
                    file_path
                ],
                capture_output=True,
                timeout=60  # 60 second timeout
            )
            
            # Parse output
            output = result.stdout.decode().strip()
            
            # Return code meanings:
            # 0 = no threats found
            # 1 = threats found
            # 2 = error
            
            if result.returncode == 0:
                logger.debug(f"File clean: {file_path}")
                return True, "Clean"
            elif result.returncode == 1:
                logger.warning(f"Malware detected in {file_path}: {output}")
                return False, output
            else:
                # Error occurred
                error_output = result.stderr.decode().strip()
                logger.error(f"ClamAV scan error: {error_output}")
                # On error, fail safe by allowing the file
                return True, f"Scan error: {error_output}"
        
        except subprocess.TimeoutExpired:
            logger.error(f"ClamAV scan timeout for {file_path}")
            # On timeout, fail safe
            return True, "Scan timeout"
        
        except Exception as e:
            logger.error(f"Malware scan exception: {e}")
            # On exception, fail safe
            return True, f"Scan exception: {str(e)}"
    
    def scan_bytes(self, content: bytes, temp_path: str) -> Tuple[bool, Optional[str]]:
        """
        Scan bytes content for malware.
        
        Args:
            content: File content bytes
            temp_path: Temporary file path to write content
        
        Returns:
            Tuple of (is_clean, scan_result)
        """
        if not self.enabled or not self.available:
            return True, "Scanning disabled or unavailable"
        
        try:
            # Write to temp file
            with open(temp_path, 'wb') as f:
                f.write(content)
            
            # Scan the temp file
            return self.scan_file(temp_path)
        
        except Exception as e:
            logger.error(f"Error scanning bytes: {e}")
            return True, f"Scan error: {str(e)}"


# Global scanner instance
_scanner = None


def get_scanner() -> MalwareScanner:
    """Get or create the global malware scanner instance."""
    global _scanner
    if _scanner is None:
        _scanner = MalwareScanner()
    return _scanner


def scan_file(file_path: str) -> Tuple[bool, Optional[str]]:
    """
    Convenience function to scan a file.
    
    Args:
        file_path: Path to file
    
    Returns:
        Tuple of (is_clean, scan_result)
    """
    scanner = get_scanner()
    return scanner.scan_file(file_path)


def scan_bytes(content: bytes, temp_path: str) -> Tuple[bool, Optional[str]]:
    """
    Convenience function to scan bytes content.
    
    Args:
        content: File content bytes
        temp_path: Temporary file path
    
    Returns:
        Tuple of (is_clean, scan_result)
    """
    scanner = get_scanner()
    return scanner.scan_bytes(content, temp_path)



