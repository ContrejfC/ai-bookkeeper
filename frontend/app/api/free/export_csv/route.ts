/**
 * Free Tool Export CSV API Route
 * 
 * Exports categorized transactions as watermarked CSV.
 */

import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { readFile } from 'fs/promises';
import { join } from 'path';
import { exportCsvSchema, loadFreeToolConfig } from '@/lib/validators';
import { checkEmailRateLimit } from '@/lib/rateLimit';

export async function POST(request: NextRequest) {
  try {
    // Parse request body
    const body = await request.json();
    
    // Validate input
    const validated = exportCsvSchema.parse(body);
    const { upload_id, email_token, consent } = validated;
    
    if (!consent) {
      return NextResponse.json(
        { error: 'Consent required', code: 'CONSENT_REQUIRED' },
        { status: 400 }
      );
    }
    
    // Verify email token from cookie
    const cookieStore = cookies();
    const storedToken = cookieStore.get('email_token')?.value;
    
    if (!storedToken || storedToken !== email_token) {
      return NextResponse.json(
        { error: 'Invalid or expired email token', code: 'TOKEN_INVALID' },
        { status: 401 }
      );
    }
    
    // Decode token
    const tokenData = JSON.parse(Buffer.from(storedToken, 'base64').toString());
    
    if (tokenData.expires_at < Date.now()) {
      return NextResponse.json(
        { error: 'Email verification expired', code: 'TOKEN_EXPIRED' },
        { status: 401 }
      );
    }
    
    // Check email rate limit
    const rateLimitResult = await checkEmailRateLimit(tokenData.email);
    
    if (!rateLimitResult.allowed) {
      return NextResponse.json(
        {
          error: 'Daily export limit reached (3 per day)',
          code: 'EXPORT_RATE_LIMIT',
          retry_after: Math.ceil((rateLimitResult.resetAt.getTime() - Date.now()) / 1000)
        },
        { status: 429 }
      );
    }
    
    // Read stored categorization results
    const tempDir = process.env.TEMP_STORAGE_PATH || '/tmp/free_uploads';
    const uploadDir = join(tempDir, upload_id);
    
    // Get metadata
    const metadataPath = join(uploadDir, 'metadata.json');
    const metadata = JSON.parse(await readFile(metadataPath, 'utf-8'));
    
    // Get categorized data from backend (or read cached results)
    const transactions = await getCategorizedTransactions(upload_id, uploadDir, metadata);
    
    // Apply watermark and generate CSV
    const csv = generateWatermarkedCSV(transactions);
    
    // Generate filename
    const filename = `free_${new Date().toISOString().split('T')[0]}_categorized.csv`;
    
    // Return CSV as download
    return new NextResponse(csv, {
      status: 200,
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Cache-Control': 'no-cache, no-store, must-revalidate'
      }
    });
    
  } catch (error) {
    console.error('Export error:', error);
    
    return NextResponse.json(
      {
        error: 'Export failed',
        code: 'EXPORT_ERROR',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

/**
 * Get categorized transactions (from cache or backend)
 */
async function getCategorizedTransactions(uploadId: string, uploadDir: string, metadata: any): Promise<any[]> {
  // Check if results are cached
  const cacheFile = join(uploadDir, 'results.json');
  
  try {
    const cached = await readFile(cacheFile, 'utf-8');
    return JSON.parse(cached).transactions || [];
  } catch {
    // Not cached, call backend
    const apiBase = process.env.BACKEND_API_BASE || 'http://localhost:8000';
    const apiKey = process.env.BACKEND_API_KEY;
    
    const filePath = join(uploadDir, metadata.filename);
    const fileBuffer = await readFile(filePath);
    
    const formData = new FormData();
    const blob = new Blob([fileBuffer], { type: metadata.mime_type });
    formData.append('file', blob, metadata.filename);
    
    const response = await fetch(`${apiBase}/api/ingestion/upload`, {
      method: 'POST',
      headers: {
        'X-Free-Mode': 'true',
        ...(apiKey && { 'Authorization': `Bearer ${apiKey}` })
      },
      body: formData
    });
    
    if (!response.ok) {
      throw new Error('Backend categorization failed');
    }
    
    const result = await response.json();
    return result.transactions || [];
  }
}

/**
 * Generate watermarked CSV
 */
function generateWatermarkedCSV(transactions: any[]): string {
  const config = loadFreeToolConfig();
  const lines: string[] = [];
  
  // Add watermark header comment
  lines.push(config.watermark?.header_comment || '# Generated by AI-Bookkeeper Free Tool â€¢ Watermarked');
  lines.push('');
  
  // Add CSV header with watermark column
  const columns = config.output_columns || ['date', 'description', 'amount', 'category', 'confidence', 'notes'];
  const headerWithWatermark = [...columns, config.watermark?.column_name || 'free_tier'];
  lines.push(headerWithWatermark.join(','));
  
  // Cap at 500 rows
  const maxRows = config.max_rows || 500;
  const cappedTransactions = transactions.slice(0, maxRows);
  
  // Add data rows
  for (const txn of cappedTransactions) {
    const row = [
      escapeCSV(txn.date || txn.post_date || ''),
      escapeCSV((txn.description || '').slice(0, 80)), // Truncate for privacy
      (txn.amount || 0).toFixed(2),
      escapeCSV(txn.category || 'Uncategorized'),
      (txn.confidence || 0).toFixed(2),
      escapeCSV(txn.notes || ''),
      config.watermark?.column_value || 'watermarked'
    ];
    
    lines.push(row.join(','));
  }
  
  // Add footer note if truncated
  if (transactions.length > maxRows) {
    lines.push('');
    lines.push(config.watermark?.footer_note || '# *** Truncated at 500 rows. Upgrade to process unlimited rows ***');
  }
  
  return lines.join('\n');
}

/**
 * Escape CSV field
 */
function escapeCSV(field: string): string {
  if (!field) return '';
  
  const fieldStr = String(field);
  
  // Escape quotes and wrap in quotes if contains comma, quote, or newline
  if (fieldStr.includes(',') || fieldStr.includes('"') || fieldStr.includes('\n')) {
    return `"${fieldStr.replace(/"/g, '""')}"`;
  }
  
  return fieldStr;
}

